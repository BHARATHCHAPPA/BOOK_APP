import { FastifyInstance } from 'fastify';
import { DynamoBookRepository } from '../../infrastructure/database/DynamoBookRepository';
import { DynamoCreditRepository } from '../../infrastructure/database/DynamoCreditRepository';
import { IPurchase } from '../../domain/models';
import { z } from 'zod';

const bookRepo = new DynamoBookRepository();
const creditRepo = new DynamoCreditRepository();

const createBookSchema = z.object({
    title: z.string().min(1).max(200),
    author: z.string().min(1).max(100),
    description: z.string().min(1).max(2000),
    coverImage: z.string().url(),
    price: z.number().int().min(0),
    ageRange: z.object({
        min: z.number().int().min(0).max(18),
        max: z.number().int().min(0).max(18)
    }),
    genre: z.array(z.string()),
    readingLevel: z.enum(['beginner', 'intermediate', 'advanced']),
    pageCount: z.number().int().min(1),
    publishedDate: z.string(),
    isbn: z.string().optional(),
    rating: z.number().min(0).max(5).optional(),
    reviewCount: z.number().int().min(0).optional()
});

const updateBookSchema = createBookSchema.partial();

const purchaseBookSchema = z.object({
    childId: z.string().optional()
});

export function bookRoutes(fastify: FastifyInstance) {
    // GET /books - List all books (with pagination)
    fastify.get('/books', async (req, reply) => {
        const { limit, lastKey, genre } = req.query as any;

        try {
            if (genre) {
                const books = await bookRepo.findByGenre(genre, limit ? parseInt(limit) : 50);
                return reply.send({ books });
            }

            const result = await bookRepo.findAll(limit ? parseInt(limit) : 50, lastKey);
            return reply.send(result);
        } catch (error: any) {
            if (error.name === 'CredentialsProviderError') {
                return reply.send({ books: [], _mock: true });
            }
            throw error;
        }
    });

    // GET /books/:id - Get specific book
    fastify.get('/books/:id', async (req, reply) => {
        const { id } = req.params as { id: string };

        try {
            const book = await bookRepo.findById(id);

            if (!book) {
                return reply.status(404).send({ message: 'Book not found' });
            }

            return reply.send(book);
        } catch (error: any) {
            if (error.name === 'CredentialsProviderError') {
                return reply.status(404).send({ message: 'Book not found (dev mode)' });
            }
            throw error;
        }
    });

    // POST /books - Create new book (admin only - add role check in production)
    fastify.post('/books', async (req, reply) => {
        const user = (req as any).user;

        // TODO: Add admin role check
        // if (user.role !== 'ADMIN') {
        //     return reply.status(403).send({ message: 'Admin access required' });
        // }

        try {
            const bookData = createBookSchema.parse(req.body);
            const book = await bookRepo.create(bookData);
            return reply.status(201).send(book);
        } catch (error: any) {
            if (error.name === 'ZodError') {
                return reply.status(400).send({ message: 'Invalid input', errors: error.errors });
            }
            if (error.name === 'CredentialsProviderError') {
                return reply.status(201).send({
                    id: 'mock-book-id',
                    ...(req.body as any),
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    _mock: true
                });
            }
            throw error;
        }
    });

    // PUT /books/:id - Update book (admin only)
    fastify.put('/books/:id', async (req, reply) => {
        const { id } = req.params as { id: string };

        try {
            const updates = updateBookSchema.parse(req.body);
            const updated = await bookRepo.update(id, updates);
            return reply.send(updated);
        } catch (error: any) {
            if (error.name === 'ZodError') {
                return reply.status(400).send({ message: 'Invalid input', errors: error.errors });
            }
            if (error.name === 'CredentialsProviderError') {
                return reply.send({ id, ...req.body, _mock: true });
            }
            throw error;
        }
    });

    // DELETE /books/:id - Delete book (admin only)
    fastify.delete('/books/:id', async (req, reply) => {
        const { id } = req.params as { id: string };

        try {
            await bookRepo.delete(id);
            return reply.status(204).send();
        } catch (error: any) {
            if (error.name === 'CredentialsProviderError') {
                return reply.status(204).send();
            }
            throw error;
        }
    });

    // POST /books/:id/purchase - Purchase a book
    fastify.post('/books/:id/purchase', async (req, reply) => {
        const user = (req as any).user;
        const { id: bookId } = req.params as { id: string };

        try {
            const { childId } = purchaseBookSchema.parse(req.body);

            // Check if already purchased
            const alreadyPurchased = await bookRepo.hasPurchased(user.id, bookId);
            if (alreadyPurchased) {
                return reply.status(400).send({ message: 'Book already purchased' });
            }

            // Get book details
            const book = await bookRepo.findById(bookId);
            if (!book) {
                return reply.status(404).send({ message: 'Book not found' });
            }

            // Spend credits
            await creditRepo.spendCredits(
                user.id,
                book.price,
                `Purchase: ${book.title}`,
                bookId
            );

            // Create purchase record
            const purchase = await bookRepo.createPurchase(user.id, bookId, book.price, childId);

            return reply.status(201).send({
                message: 'Book purchased successfully',
                purchase,
                book
            });
        } catch (error: any) {
            if (error.message === 'Insufficient credits') {
                return reply.status(400).send({ message: 'Insufficient credits' });
            }
            if (error.name === 'ZodError') {
                return reply.status(400).send({ message: 'Invalid input', errors: error.errors });
            }
            if (error.name === 'CredentialsProviderError') {
                return reply.status(201).send({
                    message: 'Book purchased successfully (dev mode)',
                    _mock: true
                });
            }
            throw error;
        }
    });

    // GET /books/purchased - Get user's purchased books
    fastify.get('/books/purchased', async (req, reply) => {
        const user = (req as any).user;

        try {
            const purchases = await bookRepo.findPurchasesByUser(user.id);

            // Fetch book details for each purchase
            const booksWithDetails = await Promise.all(
                purchases.map(async (purchase: IPurchase) => {
                    const book = await bookRepo.findById(purchase.bookId);
                    return {
                        ...purchase,
                        book
                    };
                })
            );

            return reply.send(booksWithDetails);
        } catch (error: any) {
            if (error.name === 'CredentialsProviderError') {
                return reply.send([]);
            }
            throw error;
        }
    });
}
